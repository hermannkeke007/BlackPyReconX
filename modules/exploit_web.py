import requests
from bs4 import BeautifulSoup
import os
import re
import threading
from queue import Queue
from urllib.parse import urljoin

# La session sera injectée par main.py
session = None

# Liste des en-têtes de sécurité à vérifier
SECURITY_HEADERS = [
    'Content-Security-Policy',
    'Strict-Transport-Security',
    'X-Content-Type-Options',
    'X-Frame-Options',
    'Referrer-Policy',
    'Permissions-Policy'
]

# Listes de payloads pour les tests
XSS_PAYLOADS = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg/onload=alert("XSS")>'
]

LFI_PAYLOADS = [
    '../../../../../../../../etc/passwd',
    '../../../../../../../../windows/win.ini'
]

SQLI_PAYLOADS = [
    "' OR 1=1 --",
    '" OR 1=1 --',
    "' OR 'a'='a'",
    '--',
    "\'",
    '"'
]

# --- Fonctions de test (pour le parallélisme) ---

def check_security_headers(url, session, results_dict):
    results = "--- ANALYSE DES EN-TÊTES DE SÉCURITÉ ---\n"
    try:
        response = session.get(url, timeout=5)
        headers = response.headers
        results += f"En-têtes pour {url}:\n"
        missing_headers = []
        for header in SECURITY_HEADERS:
            if header not in headers:
                missing_headers.append(header)
                results += f"  [!] Manquant : {header}\n"
            else:
                results += f"  [+] Présent : {header} = {headers[header]}\n"
        if not missing_headers:
            results += "Tous les en-têtes de sécurité recommandés sont présents.\n"
    except requests.exceptions.RequestException as e:
        results += f"Erreur lors de la récupération des en-têtes : {e}\n"
    results_dict['headers'] = results + "\n"

def find_forms_and_test_xss(url, session, results_dict):
    results = "--- TEST DE VULNÉRABILITÉ XSS (basique) ---\n"
    try:
        response = session.get(url, timeout=5)
        soup = BeautifulSoup(response.content, 'html.parser')
        forms = soup.find_all('form')
        if not forms:
            results += "Aucun formulaire trouvé sur la page.\n"
            results_dict['xss'] = results
            return

        results += f"{len(forms)} formulaire(s) trouvé(s) sur {url}.\n"
        
        for form in forms:
            action = form.get('action')
            method = form.get('method', 'get').lower()
            inputs = form.find_all(['input', 'textarea'])
            
            form_details = f"  [>] Test du formulaire avec action '{action}' et méthode '{method}'\n"
            results += form_details

            for payload in XSS_PAYLOADS:
                data = {}
                for i in inputs:
                    name = i.get('name')
                    if name:
                        data[name] = payload
                
                try:
                    target_url = urljoin(url, action)
                    if method == 'post':
                        res = session.post(target_url, data=data, timeout=3)
                    else:
                        res = session.get(target_url, params=data, timeout=3)

                    if payload in res.text:
                        results += f"    [!] Potentiel XSS trouvé avec le payload : {payload}\n"
                        break
                except requests.exceptions.RequestException:
                    pass
            else:
                 results += "    [+] Aucune vulnérabilité XSS simple détectée pour ce formulaire.\n"

    except requests.exceptions.RequestException as e:
        results += f"Erreur lors de l'accès à la page : {e}\n"
    results_dict['xss'] = results + "\n"

def test_lfi(url, session, results_dict):
    results = "--- TEST DE VULNÉRABILITÉ LFI (basique) ---\n"
    if '?' not in url:
        results += "Aucun paramètre trouvé dans l'URL pour un test LFI simple.\n"
        results_dict['lfi'] = results
        return

    base_url = url.split('?')[0]
    params = url.split('?')[1].split('&')
    
    for param in params:
        key = param.split('=')[0]
        results += f"  [>] Test du paramètre '{key}' pour LFI...\n"
        for payload in LFI_PAYLOADS:
            test_url = f"{base_url}?{key}={payload}"
            try:
                response = session.get(test_url, timeout=3)
                if "root:x:0:0" in response.text or "[fonts]" in response.text:
                    results += f"    [!] Potentiel LFI trouvé ! URL: {test_url}\n"
                    break
            except requests.exceptions.RequestException:
                pass
        else:
            results += "    [+] Aucune vulnérabilité LFI simple détectée pour ce paramètre.\n"
    results_dict['lfi'] = results + "\n"

def test_sqli(url, session, results_dict):
    results = "--- TEST D'INJECTION SQL (basique) ---\n"
    if '=' not in url:
        results += "Aucun paramètre trouvé dans l'URL pour un test SQLi simple.\n"
        results_dict['sqli'] = results
        return

    parts = url.split("?")
    base_url = parts[0]
    if len(parts) < 2:
        results_dict['sqli'] = results
        return

    params = parts[1].split("&")
    for i, param in enumerate(params):
        key, _ = param.split("=", 1)
        results += f"  [>] Test du paramètre '{key}' pour SQLi...\n"
        for payload in SQLI_PAYLOADS:
            test_params = params[:]
            test_params[i] = f"{key}={payload}"
            test_url = f"{base_url}?{'&'.join(test_params)}"
            try:
                response = session.get(test_url, timeout=3)
                if re.search(r"(SQL syntax|mysql_fetch|Syntax error|Unclosed quotation mark)", response.text, re.IGNORECASE):
                    results += f"    [!] Potentiel SQLi trouvé ! URL: {test_url}\n"
                    break
            except requests.exceptions.RequestException:
                pass
        else:
            results += "    [+] Aucune erreur SQL détectée pour ce paramètre.\n"
    results_dict['sqli'] = results + "\n"

# --- Recherche de chemins parallélisée ---
path_queue = Queue()
found_paths_list = []

def path_scan_worker(base_url, session):
    while not path_queue.empty():
        path = path_queue.get()
        test_url = urljoin(base_url, path)
        try:
            response = session.get(test_url, timeout=5, allow_redirects=False)
            if response.status_code == 200:
                found_paths_list.append(test_url)
        except requests.exceptions.RequestException:
            pass
        finally:
            path_queue.task_done()

def find_sensitive_paths_parallel(url, session, results_dict):
    global found_paths_list
    found_paths_list = []
    results = "--- RECHERCHE DE FICHIERS ET DOSSIERS SENSIBLES ---"
    wordlist_path = os.path.join(os.path.dirname(__file__), '..', 'data', 'common_paths.txt')
    
    try:
        with open(wordlist_path, 'r') as f:
            paths = [line.strip() for line in f if line.strip() and not line.startswith('#')]
    except FileNotFoundError:
        results += f"[!] Fichier de wordlist non trouvé : {wordlist_path}\n"
        results_dict['sensitive_paths'] = results
        return

    for path in paths:
        path_queue.put(path)

    threads = []
    for _ in range(50): # 50 threads pour la recherche de chemins
        thread = threading.Thread(target=path_scan_worker, args=(url, session,), daemon=True)
        thread.start()
        threads.append(thread)
    path_queue.join()

    if found_paths_list:
        for path in sorted(found_paths_list):
            results += f"  [!] Trouvé : {path} (Code: 200)\n"
    else:
        results += "Aucun fichier ou dossier sensible trouvé à partir de la liste de base.\n"
    
    results_dict['sensitive_paths'] = results + "\n"

def run(target):
    if session is None:
        raise Exception("La session de requêtes n'a pas été initialisée.")

    print(f"[+] Lancement des tests de vulnérabilités web sur {target}...")
    if not target.startswith('http'):
        target_url = f"http://{target}"
    else:
        target_url = target

    results = {}
    threads = []

    tasks = [
        (check_security_headers, (target_url, session, results)),
        (find_forms_and_test_xss, (target_url, session, results)),
        (test_lfi, (target_url, session, results)),
        (test_sqli, (target_url, session, results)),
        (find_sensitive_paths_parallel, (target_url, session, results))
    ]

    for func, args in tasks:
        thread = threading.Thread(target=func, args=args, daemon=True)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    all_results = f"--- RÉSULTATS DES TESTS WEB POUR {target_url} ---\n\n"
    all_results += results.get('headers', '')
    all_results += results.get('xss', '')
    all_results += results.get('lfi', '')
    all_results += results.get('sqli', '')
    all_results += results.get('sensitive_paths', '')

    output_path = os.path.join(os.path.dirname(__file__), '..', 'outputs', 'web_vulns.txt')
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(all_results)

    print(f"[+] Résultats des tests web enregistrés dans {output_path}")
    print(all_results)
